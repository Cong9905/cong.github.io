<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Chart with Auto Prediction</title>
    <script src="https://s3.tradingview.com/tv.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .tradingview-widget-container {
            margin: 20px 0;
        }
        label {
            margin-right: 10px;
        }
        select, button {
            margin-right: 20px;
            padding: 5px 10px;
        }
        .timer {
            font-size: 1.5em;
            margin: 10px 0;
            color: #555;
        }
        .arrow {
            font-size: 2em;
            display: inline-block;
        }
        .up-arrow {
            color: green;
        }
        .down-arrow {
            color: red;
        }
        #result, #warning {
            font-size: 1.2em;
            margin: 10px 0;
        }
        #accuracy {
            font-size: 1em;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>BTC/USDT Chart</h1>

    <div class="tradingview-widget-container">
        <div id="tradingview_12345"></div>
        <script type="text/javascript">
            new TradingView.widget({
                "container_id": "tradingview_12345",
                "symbol": "BINANCE:BTCUSDT",
                "interval": "30S",
                "timezone": "Etc/UTC",
                "theme": "light",
                "style": "1",
                "locale": "en",
                "toolbar_bg": "#f1f3f6",
                "enable_publishing": false,
                "withdateranges": true,
                "hide_side_toolbar": false,
                "allow_symbol_change": true,
                "studies": ["BB@tv-basicstudies"],
                "show_popup_button": true,
                "popup_width": "1000",
                "popup_height": "650",
                "no_referral_id": true,
            });
        </script>
    </div>

    <div>
        <label for="chartInterval">Chọn thời gian biểu đồ:</label>
        <select id="chartInterval">
            <option value="30s">30 Giây</option>
            <option value="1m">1 Phút</option>
        </select>

        <label for="provider">Chọn nhà cung cấp dữ liệu cho 30 giây:</label>
        <select id="provider">
            <option value="binance">Binance</option>
            <option value="other">Các trang khác</option>
        </select>

        <label for="option">Chọn tính toán:</label>
        <select id="option">
            <option value="14">14 nến gần nhất</option>
            <option value="3">3 nến gần nhất</option>
        </select>
        <button id="predictButton" onclick="startAutoPrediction()">Bắt đầu dự đoán liên tục</button>
        <button id="resetButton" onclick="resetPrediction()">Đặt lại</button>
    </div>

    <div class="timer" id="countdownTimer">Thời gian đến dự đoán: 30s</div>
    <div id="result"></div>
    <div id="warning"></div>
    <p id="accuracy"></p>

    <script>
        let correctPredictions = 0;
        let incorrectPredictions = 0;
        let totalPredictions = 0;
        let predictionInterval;
        let countdownInterval;
        let timeLeft = 30; // Thời gian đếm ngược
        const predictionOffset = 5000; // Đưa ra dự đoán trước 5 giây
        const resultsHistory = [];
        const lossThreshold = 0.2; // Ngưỡng thua
        let currentRsiThreshold = { upper: 70, lower: 30 }; // Ngưỡng RSI ban đầu

        async function fetchKlines(symbol, interval, limit) {
            const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.statusText}`);
            }
            const data = await response.json();
            return data;
        }

        function convertTo30sCandles(data) {
            const thirtySecondCandles = [];
            for (let i = 0; i < data.length; i++) {
                const open = parseFloat(data[i][1]);
                const close = parseFloat(data[i][4]);
                const high = Math.max(open, close, parseFloat(data[i][2]), parseFloat(data[i][3]));
                const low = Math.min(open, close, parseFloat(data[i][2]), parseFloat(data[i][3]));
                const volume = parseFloat(data[i][5]);

                // Thêm 2 nến 30 giây cho mỗi nến 1 phút
                thirtySecondCandles.push([data[i][0], open, high, low, close / 2, volume / 2]);
                thirtySecondCandles.push([data[i][0] + 30000, open, high, low, close / 2, volume / 2]); // 30000 ms = 30s
            }
            return thirtySecondCandles;
        }

        function calculateRSI(prices) {
            let gains = 0;
            let losses = 0;
            for (let i = 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            const averageGain = gains / prices.length;
            const averageLoss = losses / prices.length;
            const rs = averageGain / averageLoss;
            return 100 - (100 / (1 + rs));
        }

        function analyzeVolume(data) {
            const volumes = data.map(candle => parseFloat(candle[5]));
            const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
            return avgVolume;
        }

        function predictTrend(rsi, avgVolume, lastVolume) {
            if (rsi > currentRsiThreshold.upper) {
                return ["Giảm", 70];
            } else if (rsi < currentRsiThreshold.lower) {
                return ["Tăng", 70];
            } else if (rsi >= currentRsiThreshold.lower && rsi <= currentRsiThreshold.upper) {
                if (lastVolume > avgVolume) {
                    return ["Tăng", 60];
                } else if (lastVolume < avgVolume) {
                    return ["Giảm", 60];
                } else {
                    return ["Không xác định", 50]; // Trả về không xác định nếu khối lượng không khác biệt
                }
            } else {
                return ["Không xác định", 50]; // Bảo đảm sẽ có giá trị trở về nếu không thỏa mãn điều kiện
            }
        }

        async function makePrediction(option) {
            console.log("Thực hiện dự đoán với tùy chọn:", option);
            const limit = parseInt(option);
            const interval = document.getElementById("chartInterval").value;
            const provider = document.getElementById("provider").value;

            let data;
            if (interval === "30s" && provider === "binance") {
                data = await fetchKlines("BTCUSDT", "1m", limit);
                data = convertTo30sCandles(data);
            } else {
                data = await fetchKlines("BTCUSDT", interval, limit);
            }

            const prices = data.map(candle => parseFloat(candle[4]));
            const rsi = calculateRSI(prices);
            const avgVolume = analyzeVolume(data);
            const lastVolume = parseFloat(data[data.length - 1][5]);

            console.log(`RSI: ${rsi.toFixed(2)}, Avg Volume: ${avgVolume}, Last Volume: ${lastVolume}`);

            const [trend, probability] = predictTrend(rsi, avgVolume, lastVolume);

            // Kiểm tra dự đoán với giá thực tế
            const previousClose = parseFloat(data[data.length - 2][4]); // Giá đóng của nến trước
            const currentOpen = parseFloat(data[data.length - 1][1]);   // Giá mở của nến hiện tại
            const actualDirection = (currentOpen > previousClose) ? "Tăng" : "Giảm"; // Xu hướng thực tế dựa trên mở và đóng

            const isCorrect = (trend.includes(actualDirection)); // So sánh xu hướng dự đoán với xu hướng thực tế

            if (isCorrect) {
                correctPredictions++;
                resultsHistory.push({ prediction: trend, actual: actualDirection, correct: true });
            } else {
                incorrectPredictions++;
                resultsHistory.push({ prediction: trend, actual: actualDirection, correct: false });
            }

            totalPredictions++;

            // Hiển thị kết quả
            document.getElementById("result").innerHTML = `Dự đoán: ${trend}, Thực tế: ${actualDirection} (${probability}%)`;
            const arrow = trend === "Tăng" ? `<span class="arrow up-arrow">↑</span>` : `<span class="arrow down-arrow">↓</span>`;
            document.getElementById("result").innerHTML += arrow;

            // Cập nhật tỷ lệ chính xác
            const accuracyPercentage = ((correctPredictions / totalPredictions) * 100).toFixed(2);
            const incorrectPercentage = ((incorrectPredictions / totalPredictions) * 100).toFixed(2);
            document.getElementById("accuracy").innerHTML = `Tổng số lượt dự đoán: ${totalPredictions}, Đúng: ${correctPredictions} (${accuracyPercentage}%), Sai: ${incorrectPredictions} (${incorrectPercentage}%) (Học hỏi từ các phương pháp để tăng tỷ lệ win)`;

            // Cảnh báo nếu thị trường biến động mạnh
            if (Math.abs(lastVolume - avgVolume) > avgVolume * lossThreshold) {
                document.getElementById("warning").innerHTML = "⚠️ Cảnh báo: Thị trường biến động mạnh! Không nên giao dịch!";
            } else {
                document.getElementById("warning").innerHTML = "";
            }

            // Reset countdown and timeLeft for next prediction
            timeLeft = 30;
        }

        function startAutoPrediction() {
            resetCountdown();
            const option = document.getElementById("option").value;

            predictionInterval = setInterval(async () => {
                await makePrediction(option);
            }, 30000); // Dự đoán mỗi 30 giây

            countdownInterval = setInterval(() => {
                if (timeLeft > 0) {
                    document.getElementById("countdownTimer").innerText = `Thời gian đến dự đoán: ${timeLeft}s`;
                    timeLeft--;
                } else {
                    timeLeft = 30; // Reset lại thời gian đếm ngược về 30 giây
                }
            }, 1000); // Cập nhật đếm ngược mỗi giây
        }

        function resetCountdown() {
            clearInterval(countdownInterval);
            timeLeft = 30;
            document.getElementById("countdownTimer").innerText = `Thời gian đến dự đoán: ${timeLeft}s`;
        }

        function resetPrediction() {
            clearInterval(predictionInterval);
            resetCountdown();
            correctPredictions = 0;
            incorrectPredictions = 0;
            totalPredictions = 0;
            document.getElementById("result").innerHTML = "";
            document.getElementById("accuracy").innerHTML = "";
            document.getElementById("warning").innerHTML = "";
            currentRsiThreshold = { upper: 70, lower: 30 }; // Đặt lại ngưỡng RSI
        }
    </script>
</body>
</html>
